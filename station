# app.R - same functionality but WITHOUT Seurat/SeuratObject (they are not needed by this app)

library(shiny)
library(shinyWidgets)
library(impute)
library(leaflet)
library(raster)
library(rgdal)
library(geojsonio)
library(stringdist)
library(rmapshaper)
library(pcaMethods)
library(imputeTS)
library(zip) 
library(BiocManager)
# removed SeuratObject and Seurat to avoid heavy Matrix dependency problems
library(Metrics)

options(repos = BiocManager::repositories())
options(shiny.maxRequestSize = 100*1024^2)

# UI ----
ui <- fluidPage(
  fluidPage(
    fluidRow(
      column(12,
             h2("Missing Values Imputation App"),
             p("This app is designed to work with CSV files generated by the ",
               strong("weathercan"), " R package. It allows you to explore and 
        impute gaps in daily or hourly climate station records using several 
        methods, such as linear regression, K-nearest neighbors (KNN), or 
        principal component analysis (PCA). 
        Optionally, you can apply a moving average after imputation to smooth 
        the results.",
               style = "font-size:90%; color:#555;")
      )
    )),
  tags$img(height = 80, with = 80, src = "ravenbanner180.png"),
  sidebarLayout(
    sidebarPanel(
      tags$h6(helpText(tags$b("Check the link below to see how to generate input file:"))),
      tags$h6(tags$a("Generate input", href = "https://github.com/rarabzad/LR/blob/main/README.md")),
      tags$h6(helpText(tags$b("Or you can find an example file here:"))),
      tags$h6(tags$a("Example", href = "https://github.com/rarabzad/LR/raw/main/data.zip")),
      fileInput(
        inputId = "datafile",
        label = "(1) Choose CSV file of the met data",
        multiple = FALSE,
        accept = c(
          "text/csv",
          "text/comma-separated-values,text/plain",
          ".csv"
        )
      ),
      dateInput(inputId = 'start_date',label='Start Date:',width = 150,value = as.Date("2000-01-01")),
      dateInput(inputId = 'end_date'  ,label='End Date:'  ,width = 150,value = as.Date("2000-01-01")),
      radioButtons("time_interval",label = "Select time interval:",choices = c("day","month"),selected = "day"),
      tags$hr(),
      
      checkboxGroupInput(inputId = "vars",label = "select variables to impute:",
                         choices = c("max_temp","mean_temp","min_temp","total_precip","total_rain","total_snow"),
                         selected = c("max_temp","min_temp","total_precip")),
      
      radioButtons("fillingMethod1",
                   label = "Select missing value imputation method:",
                   choices = c("LR", "KNN", "PCA"),
                   selected = "LR"),
      
      conditionalPanel(
        condition = "input.fillingMethod1 == 'PCA'",
        selectInput(inputId = "pcaMethod",
                    label = "Select PCA method:",
                    choices = c("ppca", "bpca", "svdImpute", "nlpca")),
        numericInput(inputId = 'nPcs',
                     label = 'Enter number of PCs:',
                     width = "150px", value = 1, min = 1, max = 10)
      ),
      
      conditionalPanel(
        condition = "input.fillingMethod1 == 'KNN'",
        numericInput(inputId = 'neighbors',
                     label = 'Enter number of neighbors:',
                     width = "150px", value = 1, min = 1, max = 30)
      ),
      
      # Show the MA option only when method is NOT KNN
      conditionalPanel(
        condition = "input.fillingMethod1 != 'KNN'",
        radioButtons("fillingMethod2",
                     label = "Apply moving average after imputation?",
                     choices = c("No", "Yes"),
                     selected = "No", inline = TRUE),
        
        # Show MA window size only when user selects "Yes"
        conditionalPanel(
          condition = "input.fillingMethod2 == 'Yes'",
          numericInput(inputId = 'window',
                       label = 'MA window size (k):',
                       width = "150px", value = 1, min = 1, max = 24)
        )
      ),
      
      actionButton(inputId = "loadStation", label = "(2) Load stations",width = 200),
      textOutput("loadmessage"),
      actionButton(inputId = "impute", label = "(3) Impute missing values",width = 200),
      textOutput("imputemessage"),
      actionButton(inputId = "convert", label = "(4) Convert to rvt",width = 200),
      textOutput("convertmessage"),
      downloadButton(outputId = "download", label = "(5) Press to download rvt")
    ),
    
    mainPanel(
      multiInput(
        inputId = "selectedStations", label = "Avaialble Stations :",
        choices = character(0),
        selected = character(0), width = "800px",
        options = list(
          enable_search = TRUE,
          non_selected_header = "Choose between:",
          selected_header = "You have selected:"
        )
      ),
      plotOutput("timeframeplot"),
      leafletOutput("map")
    )
  )
)

# Server ----
server <- function(input, output, session) {
  values <- reactiveValues()
  
  # update available variables
  observeEvent(input$datafile, {
    req(input$datafile)  # make sure a file was uploaded
    
    # --- 1) quick extension check (server-side) ---
    ext <- tolower(tools::file_ext(input$datafile$name))
    if (ext != "csv") {
      showModal(modalDialog(
        title = "Invalid file type",
        "Please upload a .csv file.",
        easyClose = TRUE
      ))
      return()
    }
    
    # --- 2) quick content sanity check (first lines) ---
    first_lines <- tryCatch(
      readLines(input$datafile$datapath, n = 5, encoding = "UTF-8"),
      error = function(e) NULL
    )
    if (is.null(first_lines) || length(first_lines) == 0) {
      showModal(modalDialog("Uploaded file is empty or unreadable.", easyClose = TRUE))
      return()
    }
    header <- first_lines[1]
    if (!grepl(",", header) && !grepl(";", header) && !grepl("\t", header)) {
      showModal(modalDialog(
        title = "Not a CSV-like file",
        "The uploaded file does not appear to be CSV (no comma/semicolon/tab found on first line).",
        easyClose = TRUE
      ))
      return()
    }
    
    # --- 3) safe read with error handling ---
    data_df <- tryCatch({
      read.csv(input$datafile$datapath, stringsAsFactors = FALSE)
    }, error = function(e) {
      showModal(modalDialog(title = "Read error", paste0("Failed to read CSV: ", e$message), easyClose = TRUE))
      NULL
    })
    if (is.null(data_df)) return()
    
    # Optional cleanup: drop entirely empty first auto-named column (read.csv can create ...1)
    if ("...1" %in% names(data_df) && all(is.na(data_df$...1))) data_df$...1 <- NULL
    
    # --- 4) ensure date column exists and is parseable ---
    if (!"date" %in% names(data_df)) {
      showModal(modalDialog(title = "Missing column", "Input CSV must contain a 'date' column.", easyClose = TRUE))
      return()
    }
    # try direct as.Date first
    data_df$date <- as.Date(data_df$date)
    if (any(is.na(data_df$date))) {
      # try parsing POSIX-like strings then convert to Date
      parsed_try <- tryCatch(as.Date(as.POSIXct(data_df$date)), error = function(e) NA)
      if (all(is.na(parsed_try))) {
        showModal(modalDialog(title = "Date parse error",
                              "Could not parse 'date' column. Use YYYY-MM-DD or another standard date/time format.",
                              easyClose = TRUE))
        return()
      } else {
        data_df$date <- parsed_try
      }
    }
    
    # --- 5) load stations.csv remotely (if available), otherwise build minimal station_Info ---
    stations_data <- tryCatch({
      read.csv("https://github.com/rarabzad/weathercan_imputation/raw/refs/heads/main/LR/stations.csv", stringsAsFactors = FALSE)
    }, error = function(e) NULL)
    
    if (!"station_id" %in% names(data_df)) {
      showModal(modalDialog(title = "Missing column", "Input CSV must contain a 'station_id' column.", easyClose = TRUE))
      return()
    }
    
    station_ids <- unique(data_df$station_id)
    
    if (!is.null(stations_data)) {
      # match station metadata; allow missing metadata for some stations
      matched <- stations_data[match(station_ids, stations_data$station_id), ]
      # ensure station_name exists
      if (!"station_name" %in% names(matched)) matched$station_name <- as.character(matched$station_id)
      matched$station_name[is.na(matched$station_name)] <- as.character(matched$station_id[is.na(matched$station_name)])
      station_Info <- data.frame(
        lat = matched$lat,
        lon = matched$lon,
        elev = matched$elev,
        start = matched$start,
        end = matched$end,
        station_id = matched$station_id,
        station_name = as.character(matched$station_name),
        label = sprintf("%s (%s)", as.character(matched$station_name), matched$station_id),
        stringsAsFactors = FALSE
      )
    } else {
      # fallback minimal station info (no coords)
      station_Info <- data.frame(
        lat = rep(NA_real_, length(station_ids)),
        lon = rep(NA_real_, length(station_ids)),
        elev = rep(NA_real_, length(station_ids)),
        start = rep(as.numeric(format(min(data_df$date), "%Y")), length(station_ids)),
        end = rep(as.numeric(format(max(data_df$date), "%Y")), length(station_ids)),
        station_id = station_ids,
        station_name = as.character(station_ids),
        label = sprintf("%s (%s)", as.character(station_ids), station_ids),
        stringsAsFactors = FALSE
      )
      showNotification("Warning: remote stations.csv unavailable — using station_id as names and no coordinates.", type = "warning")
    }
    
    # --- 6) time-interval consistency check (defensive) ---
    time_interval <- input$time_interval
    flag_problem <- FALSE
    if (time_interval == "hour" && !("hour" %in% names(data_df))) flag_problem <- TRUE
    if (time_interval == "day"  && !("day"  %in% names(data_df))) flag_problem <- TRUE
    if (time_interval == "month" && !("day" %in% names(data_df))) flag_problem <- TRUE
    if (flag_problem) {
      showNotification("Warning: uploaded data may not match selected time interval (hour/day/month).", type = "warning")
      # still continue — original code used flag==0 to proceed; here we allow but warn user
    }
    
    # --- 7) write to reactiveValues and update UI controls ---
    values$data <- data_df
    values$station_Info <- station_Info
    
    vars <- c("max_temp", "mean_temp", "min_temp", "total_precip", "total_rain", "total_snow")
    availableVars <- vars[vars %in% names(data_df)]
    if (length(availableVars) == 0) {
      showModal(modalDialog(title = "No variables found", "No supported variables found in the uploaded CSV (max_temp, mean_temp, ...).", easyClose = TRUE))
      return()
    }
    
    updateCheckboxGroupInput(session, "vars",
                             label = "select variables to impute:",
                             choices = availableVars,
                             selected = availableVars)
    
    updateDateInput(session, inputId = "start_date", value = min(data_df$date))
    updateDateInput(session, inputId = "end_date",   value = max(data_df$date))
    
    # Update selectedStations choices (safe: use character(0) default in UI earlier)
    updateMultiInput(session, inputId = "selectedStations",
                     choices = station_Info$label, selected = station_Info$label)
    
    output$loadmessage <- renderText({ "File uploaded and parsed successfully." })
  })
  
  # update dates
  observeEvent(input$start_date, {
    if (!is.null(input$datafile$datapath)) {
      data <- values$data
      start_date <- as.Date(range(data$date))[1]
      if (as.Date(input$start_date) < start_date) {
        updateDateInput(session, inputId = "start_date", value = start_date)
      }
      if (input$time_interval == "month") {
        if (format(as.Date(input$start_date), "%d") != "01") {
          start_date <- paste(format(as.Date(input$start_date), "%Y-%m"), "-01", sep = "")
          updateDateInput(session, inputId = "start_date", value = start_date)
        }
      }
    }
  })
  
  observeEvent(input$end_date, {
    if (!is.null(input$datafile$datapath)) {
      data <- values$data
      end_date <- as.Date(range(data$date))[2]
      if (as.Date(input$end_date) > end_date) {
        updateDateInput(session, inputId = "end_date", value = end_date)
      }
      if (input$time_interval == "month") {
        if (format(as.Date(input$end_date), "%d") != "01") {
          end_date <- paste(format(as.Date(input$end_date), "%Y-%m"), "-01", sep = "")
          updateDateInput(session, inputId = "end_date", value = end_date)
        }
      }
    }
  })
  
  observeEvent(input$time_interval, {
    if (input$time_interval == "month") {
      if (format(as.Date(input$end_date), "%d") != "01") {
        end_date <- paste(format(as.Date(input$end_date), "%Y-%m"), "-01", sep = "")
        updateDateInput(session, inputId = "end_date", value = end_date)
      }
      if (format(as.Date(input$start_date), "%d") != "01") {
        start_date <- paste(format(as.Date(input$start_date), "%Y-%m"), "-01", sep = "")
        updateDateInput(session, inputId = "start_date", value = start_date)
      }
    }
  })
  
  # load Station
  observeEvent(input$loadStation, {
    data <- values$data
    station_Info <- values$station_Info
    start_date <- as.Date(input$start_date)
    end_date   <- as.Date(input$end_date)
    time_interval <- input$time_interval
    flag <- 0
    if (time_interval == "hour")  flag <- !("hour" %in% colnames(data))
    if (time_interval == "day")   flag <- "hour" %in% colnames(data) + !("day" %in% colnames(data))
    if (time_interval == "month") flag <- "hour" %in% colnames(data) + "day" %in% colnames(data) + !("day" %in% colnames(data))
    if (flag == 0) {
      output$map <- renderLeaflet({
        leaflet(station_Info) %>% 
          addTiles() %>% 
          addMarkers(label = ~as.character(station_Info$label))
      })
    } else {
      output$timeIntervalMessage <- "Invalid data provided. One or more stations data are not consistant with the selected time interval"
    }
    
    updateMultiInput(session, inputId = "selectedStations",
                     choices = station_Info$label, selected = station_Info$label)
    output$loadmessage <- renderText({ "loaded successfully!" })
  })
  
  # update map and data availability matrix
  observeEvent(input$selectedStations, {
    station_Info <- values$station_Info
    if (length(input$selectedStations) > 1) {
      start_date <- as.numeric(format(as.Date(input$start_date), "%Y"))
      end_date   <- as.numeric(format(as.Date(input$end_date), "%Y"))
      current_stations <- station_Info[match(input$selectedStations, station_Info$label),]
      start_all <- min(current_stations$start)
      end_all   <- max(current_stations$end)
      if (end_all < end_date) end_all <- end_date
      
      mat <- matrix(0, nrow(current_stations), length(start_all:end_all))
      rownames(mat) <- current_stations$label
      colnames(mat) <- start_all:end_all
      for (i in 1:nrow(mat)) {
        mat[i, match(current_stations$start[i]:current_stations$end[i], colnames(mat))] <- 1
      }
      mat[, match(start_date:end_date, colnames(mat))] <-
        mat[, match(start_date:end_date, colnames(mat))] * 2
      mat <- mat[order(apply(mat == 2, 1, sum)),]
      output$timeframeplot <- renderPlot({
        heatmap(mat, na.rm = TRUE,
                Colv = NA, Rowv = NA,
                scale = "none", col = c("grey", "green", "red"))
      })
      
      output$map <- renderLeaflet({
        leaflet(current_stations) %>% 
          addTiles() %>% 
          addMarkers(label = ~as.character(current_stations$label))
      })
    }
  })
  
  # impute
  observeEvent(input$impute, {
    data <- values$data
    station_Info <- values$station_Info
    start_date <- as.Date(input$start_date)
    end_date   <- as.Date(input$end_date)
    time_interval <- input$time_interval
    allDates <- seq(start_date, end_date, time_interval)
    current_stations <- station_Info[match(input$selectedStations, station_Info$label),]
    station_id <- current_stations$station_id
    stations_name <- current_stations$station_name
    params <- input$vars
    completedData <- list()
    diagMetrics <- list()
    allNaCols <- matrix(NA, length(station_id), length(params))
    rownames(allNaCols) <- station_id; colnames(allNaCols) <- params
    if (input$fillingMethod1 == "LR") {
      xyz <- current_stations
      zone <- as.numeric(names(table(floor((xyz$lon + 180) / 6) + 1)[1]))
      coordinates(xyz) <- ~lon + lat
      xyz@data <- cbind(xyz@data, coordinates(xyz))
      crs(xyz) <- crs("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")
      xyz <- spTransform(xyz, crs(sprintf("+proj=utm +zone=%d +ellps=WGS84 +datum=WGS84 +units=m +no_defs ",zone)))
      xyz <- cbind(coordinates(xyz), ele = xyz@data$elev)
      rownames(xyz) <- station_id
      source("https://raw.githubusercontent.com/rarabzad/weathercan_imputation/refs/heads/main/LR/LR.R")
    }
    
    for (i in 1:length(params)) {
      mat <- matrix(NA, length(allDates), length(station_id))
      for (j in 1:length(station_id)) {
        dat <- data[station_id[j] == data$station_id,]
        matchedDates <- cbind(1:nrow(dat), match(as.Date(dat$date), allDates))
        matchedDates <- matchedDates[!is.na(matchedDates[,2]),]
        var_values <- dat[,params[i],drop=TRUE]
        mat[matchedDates[,2], j] <- var_values[matchedDates[,1]]
      }
      
      if (input$fillingMethod1 == "KNN") {
        nonNaCols <- !(apply(is.na(mat), 2, sum) / nrow(mat)) > 0.9
        nonNaRows <- rep(TRUE, nrow(mat))
      } else {
        nonNaCols <- !apply(is.na(mat), 2, all)
        nonNaRows <- !apply(is.na(mat), 1, all)
      }
      allNaCols[, i] <- !nonNaCols
      newMat <- mat[nonNaRows, nonNaCols]
      
      if (input$fillingMethod1 == "KNN") {
        neighbors <- input$neighbors
        
        out <- tryCatch(
          expr = impute.knn(data = newMat,
                            k = neighbors,
                            rowmax = 0.9,
                            colmax = 0.9)$data,
          error = function(e) { TRUE }
        )
        if (any(class(out) == "matrix")) {
          newMat <- out
          diagMetrics[[i]] <- "No diag metrics available for KNN method!"
        } else {
          nonNaCols <- !apply(is.na(mat), 2, all)
          nonNaRows <- !apply(is.na(mat), 1, all)
          allNaCols[, i] <- !nonNaCols
          newMat <- mat[nonNaRows, nonNaCols]
          diagMetrics[[i]] <- sprintf("%s percent of data is missing. PPCA method is performed instead!",
                                      round(sum(is.na(newMat)) * 100 / prod(dim(newMat))))
          newMat <- completeObs(pca(newMat, nPcs = 2, method = "ppca"))
        }
        if (!any(params[i] == c("max_temp", "min_temp"))) newMat[newMat < 0] <- 0
        mat[nonNaRows, nonNaCols] <- newMat
        completedData[[i]] <- mat
      }
      
      if (input$fillingMethod1 == "PCA") {
        method <- input$pcaMethod
        nPcs <- as.numeric(input$nPcs)
        PCA <- pca(object = newMat, method = method, nPcs = nPcs)
        diagMetrics[[i]] <- summary(PCA)
        newMat <- completeObs(PCA)
        if (!any(params[i] == c("max_temp", "min_temp"))) newMat[newMat < 0] <- 0
        mat[nonNaRows, nonNaCols] <- newMat
        completedData[[i]] <- mat
      }
      
      if (input$fillingMethod1 == "LR") {
        colnames(newMat) <- current_stations$station_id[nonNaCols]
        res <- imputer(newMat, xyz)
        diagMetrics[[i]] <- res$metrics
        if (!any(params[i] == c("max_temp", "min_temp"))) res$newMat[res$newMat < 0] <- 0
        mat[nonNaRows, nonNaCols] <- res$newMat
        completedData[[i]] <- mat
      }
      if (input$fillingMethod1 != "KNN") {
        # Only apply MA if user explicitly selected it and `window` exists/valid
        if (isTRUE(input$fillingMethod2 == "Yes")) {
          k_window <- suppressWarnings(as.integer(input$window))
          if (is.na(k_window) || k_window < 1) k_window <- 1  # fallback safe default
          if (any(!nonNaRows)) {
            newMat <- completedData[[i]][nonNaRows, nonNaCols, drop = FALSE]
            completedData[[i]][nonNaRows, nonNaCols] <-
              apply(newMat, 2, na_ma, k = k_window)
          }
        }
      }
    }
    names(diagMetrics) <- params
    values$completedData <- completedData
    values$diagMetrics <- diagMetrics
    values$allNaCols <- allNaCols
    output$imputemessage <- renderText({ "imputed successfully!" })
    output$loadmessage <- renderText({ NULL })
  })
  
  # convert
  observeEvent(input$convert, {
    station_Info <- values$station_Info
    current_stations <- station_Info[match(input$selectedStations, station_Info$label),]
    completedData <- values$completedData
    allNaCols <- values$allNaCols
    start_date <- as.Date(input$start_date)
    end_date   <- as.Date(input$end_date)
    station_id <- current_stations$station_id
    labs <- data.frame(
      vars = c("max_temp","mean_temp","min_temp","total_precip","total_rain","total_snow"),
      labels = c("TEMP_MAX", "TEMP_MEAN","TEMP_MIN", "PRECIP","RAINFALL","SNOWFALL"),
      units = c("DegC","DegC","DegC","mm/d","mm/d","mm/d"),
      stringsAsFactors = FALSE
    )
    
    L1 <- ":MultiData"
    L2 <- paste(start_date,"00:00:00",1,end_date-start_date+1)
    L3 <- paste(":Parameters", paste(labs[match(input$vars, labs$vars),"labels"], collapse = " "))
    L4 <- paste(":Units", paste(labs[match(input$vars, labs$vars),"units"], collapse = " "))
    Lend <- ":EndMultiData"
    if (dir.exists("rvtFiles")) {
      unlink("rvtFiles", recursive = TRUE)
    }
    dir.create("rvtFiles")
    RVTFile <- ":FileType rvt ASCII Raven 3.5"
    Gauge_tpl <- c(":Gauge #station_name",
                   " :Latitude lat",
                   " :Longitude lon",
                   " :Elevation elev",
                   " :RedirectToFile fileName",
                   ":EndGauge",
                   "#############################")
    
    for (i in 1:nrow(current_stations)) {
      if (!apply(allNaCols, 1, any)[i]) {
        stnData <- matrix(NA, end_date - start_date + 1, length(input$vars))
        for (j in 1:length(input$vars)) {
          stnData[, j] <- completedData[[j]][, i]
        }
        stnData <- round(stnData, 2)
        stnData[is.na(stnData)] <- -1.2345
        stnData <- apply(stnData, 1, paste, collapse = "\t")
        L1_edited <- paste(L1 ,"   #", current_stations$station_name[i])
        stnData <- c(L1_edited, L2, L3, L4, stnData, Lend)
        fileName <- sprintf("./rvtFiles/%s.rvt", station_id[i])
        writeLines(stnData, fileName)
        gauge <- Gauge_tpl
        gauge <- gsub("station_name", current_stations$station_name[i], gauge)
        gauge <- gsub("lat", current_stations$lat[i], gauge)
        gauge <- gsub("lon", current_stations$lon[i], gauge)
        gauge <- gsub("elev", current_stations$elev[i], gauge)
        gauge <- gsub("fileName", fileName, gauge)
        RVTFile <- c(RVTFile, gauge)
      }
    }
    writeLines(RVTFile, "./rvtFiles/model.rvt")
    capture.output(values$diagMetrics, file = "./rvtFiles/diagMetrics.txt")
    output$convertmessage <- renderText({ "converted successfully!" })
    output$imputemessage <- renderText({ NULL })
  })
  
  # download
  output$download <- downloadHandler(
    filename = function() { "rvtFiles.zip" },
    content = function(file) {
      zip::zip(zipfile = file, files = dir("rvtFiles", full.names = TRUE))
    },
    contentType = "application/zip"
  )
}

# Run app
shinyApp(ui, server)

